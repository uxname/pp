# AGENT GUIDE

This repository ships the `kodu` CLI (formerly PrintProject) and expects agents to treat it as a fast, bun-powered directory summarizer.
Use this file to navigate the build steps, coding conventions, and helper utilities that we repeatedly refer to from `src/index.ts`, the config modules under `src/config`, and the CLI helpers in `src/cli` and `src/core`.

## Workflows

### Build & Run
- `bun run dev` launches the entrypoint `src/index.ts` in watch/dev mode; it mirrors what folks run locally while iterating on new CLI behavior.
- `bun run build` compiles the CLI bundle via `bun build` into `dist/index.js` (see the `build` script inside `package.json`), applying minification and targeting Node.
- `bun run prepublishOnly` is wired to `bun run build`, so publishing to npm automatically rebuilds before release.
- When you need the dist file for scripting or release testing, rely on the `dist/index.js` output generated by the `build` script before shipping.
- `bun install` is the bootstrap command for this repo; always run it (or `bun install --frozen-lockfile` in CI) before executing bundling, linting, or stripping commands so the `bun.lock` stays in sync.

### Format & Lint
- `bun run lint` runs `biome check` as defined in `package.json`; it enforces both formatting (by the built-in formatter) and lint rules central to this repo (see `biome.json`).
- `bun run lint:fix` is exactly `biome check --write` for automatic formatting and import organization; `lint:fix:unsafe` adds the `--unsafe` flag if you need more aggressive autofixes.
- `bun run ts:check` executes `tsc --noEmit` so the strict TypeScript config in `tsconfig.json` is always verified before a release.
- `bun run check` is a composite `run-p ts:check lint`, so CI or local pre-flight scripts should always call this to keep lint and type checking in sync.

### Testing
- There are no dedicated automated tests in the repository yet, so the workflow is purely type-checked and linted for now.
- When you add a test suite, prefer Bun‚Äôs built-in runner (e.g., `bun test src/commands/strip.test.ts`) so the test harness matches the runtime.
- To exercise a single spec once you add one, run `bun test path/to/test.ts` or include Bun‚Äôs `--filter`/`--testNamePattern` flags; this sticks with the `bun` tooling that already drives the CLI.
- Because no tests exist today, the single-test command is a placeholder for new suites, but the expectation is to keep a one-file run as simple as `bun test {file}` from the repo root.
- When introducing tests, put them next to the feature they cover (e.g., `src/commands/strip.test.ts`) and keep them fast; we rely on Bun‚Äôs runner, so avoid slow setup scripts.
- Any new test helpers should live under `src/__tests__` or a dedicated `tests/` folder, and should reuse the same helper utilities (`collectFilesRecursively`, `stripCommentsFromFile`) when possible.

## Code Style & Conventions

### Imports & Modules
- Always import builtin modules via `node:` prefixes (`import { resolve } from 'node:path'`), and prefer `import type` when the dependency is purely a type (see `src/types.ts`).
- Shared utilities live under `src/utils/*`, configuration resides in `src/config/*`, CLI entrypoints and commands are in `src/index.ts` + `src/commands`, and core algorithms appear under `src/core`.
- Keep side-effectful `require` calls minimal; the only place we do that is the synchronous `.gitignore` read inside `createGitignoreFilter` in `src/core/filter.ts` so we can gracefully skip missing files.
- Whenever you introduce a new module, export it via named exports so downstream code can destructure what it needs (no default exports are used anywhere today).

### Formatting & Layout
- Follow the biome formatter rules in `biome.json`: two-space indentation, single quotes for strings, `lf` line endings, and `formatter.enabled` set to true.
- Use blank lines to separate logical blocks inside functions (see `generateOutputContent` in `src/core/processor.ts` to see how it keeps try/catch, conditionals, and logging clearly spaced).
- Keep trailing commas in multiline object literals and arguments (the existing code prefers trailing commas when arguments span several lines).
- Avoid extremely long inline expressions; break them across lines with the last operator at the start of the next line as in the predicate chaining inside `PRIORITY_RULES` in `src/config/priority.ts`.

### Types & Interfaces
- The repo defines interfaces inside `src/types.ts`. Always export new shapes there when they are shared (`FileWithScore`, `OutputOptions`, `CommandOptions`, etc.).
- Keep functions fully typed, especially public helpers (e.g., `runBundle(args: string[] = []): Promise<void>`); prefer explicit return types even when TypeScript could infer them.
- Use readonly collections such as `Set<string>` for configuration constants (`DEFAULT_CONFIG` uses `Set` to store directories, files, and patterns) so you can rely on O(1) contains checks.
- When a function accepts an options bag, keep the interface flattened (see `StripOptions` in `src/commands/strip.ts`) and default missing flags via `??` or `&&` logic to match the current pattern.

### Naming & Constants
- Constants that never change, such as exported config or lookup tables, go uppercase with underscores (`DEFAULT_CONFIG`, `PRIORITY_RULES`, `SUPPORTED_EXTENSIONS`, `HISTORY_FILE`).
- CamelCase is the norm for functions, methods, and local variables (`collectFilesRecursively`, `generateOutputContent`, `filesToProcess`).
- PascalCase is reserved for classes or interfaces (`Logger`, `HistoryItem`, `PriorityRule`).
- Command options that are booleans use `no` prefixes when they disable features (`--no-gitignore`, `options.noHistory`).

### Error Handling & Logging
- Surround filesystem operations with `try/catch` and narrow the caught value to `unknown`; convert to human text with `error instanceof Error ? error.message : String(error)` before logging (see `runBundle` or `generateOutputContent`).
- Failures that should stop the process call `process.exit(1)` after reporting, while recoverable problems just log and continue (e.g., `collectFilesRecursively` swallows `EACCES`/`EPERM`).
- Logging uses `ora` spinners wherever progress matters (`runBundle`, `runStrip`, `Logger`); fall back to `console.error` when the spinner is absent.
- When logging warnings from git commands, stay friendly by printing contextual messages (`Warning: Failed to read git status.`) rather than stack traces.

### CLI Behavior & UX
- The main CLI lives in `src/index.ts`, where `commander` defines the implicit bundle command and the explicit `strip` subcommand; keep new flags aligned with the current style (description strings on their own line, chaining `.option()` calls before `.action`).
- For interactive flows, rely on `prompts` to confirm destructive work (`runStrip` uses `prompts` to ask before overwriting). Always honor `--yes` or `-y` flags to skip confirmations.
- History is stored via `~/.config/kodu/history.json` (see `src/cli/history.ts`). Update that file atomically by reading via `loadHistory`, mutating the array, and calling `saveHistory` with `JSON.stringify`.
- When calling `program.parse`, keep the default `process.argv` behavior except when replaying history (see how `showHistoryMenu` injects the stored command back into the commander parser).

### Output & Persistence
- `writeOutput` in `src/cli/output.ts` writes to stdout or a file based on `OutputOptions`. Always compute the byte size with `Buffer.from(content).length` before logging size details so the feedback matches what was written.
- When writing to disk, use `writeFileSync` with `'utf-8'` encoding; if multiple destinations are requested (`stdout` plus `--output`), print both the file summary and the total content size.
- History entries are capped at 50 (see `MAX_HISTORY_ITEMS`). When new commands arrive, deduplicate by removing matches before `unshift` so the most recent invocation stays at the top.

### File Scanning & Prioritization
- `collectFilesRecursively` is the canonical scanner: it recurses, skips `.` directories, checks `DEFAULT_CONFIG` sets, respects optional `.gitignore` filters, and pushes files with a computed `score` into an array.
- `getPriorityScore` in `src/core/filter.ts` walks through `PRIORITY_RULES` and returns the first matching rule‚Äôs `score`, so high-priority files (docs, manifests) sort earlier in `generateOutputContent`.
- Always call `shouldSkipEntry` before descending into directories; it wraps checks for dotfiles, excluded directories/files, allowed extensions, `.gitignore`, explicit exclude regexes, and binary detection (via `isBinaryFile`).
- `DEFAULT_CONFIG.EXCLUDED_DIRS`, `EXCLUDED_FILES`, and `EXCLUDED_PATTERNS` live inside `src/config/defaults.ts`; keep these sets in sync with the README‚Äôs default exclusions when new patterns become relevant.
- `DEFAULT_CONFIG.INCLUDED_EXTENSIONS_AND_FILENAMES` lets the scanner embrace manifests, docs, CSS, and script files even if they lack explicit inclusion flags; prefer adding names there rather than whitelisting ad-hoc in the scanner.
- `collectFilesRecursively` uses `relative(rootPath, fullPath).replace(/\\/g, '/')` so the CLI works consistently on Windows; don‚Äôt revert that normalization when touching paths.
- When you adjust file ordering, update both `PRIORITY_RULES` and any README explanation of how files are sorted to keep the UX predictable.

### Stripping Comments
- `runStrip` determines the target set either from git-changed files (`getGitChangedFiles`) or from a full scan when `--all` is supplied; log sample files when you do a dry run by slicing the first ten entries.
- `stripCommentsFromFile` uses regexes that preserve quoted strings while removing `//` and `/* */` comments, followed by collapsing triple line breaks; if the stripped content is identical, return `false` to avoid meaningless writes.
- Make sure any new cleanup utilities honor `SUPPORTED_EXTENSIONS` so we only touch supported scripts and avoid binary files.
- `runStrip` uses `StripOptions` (see `src/commands/strip.ts`) so every optional flag is typed; if you introduce new CLI switches, keep the options bag flat and document default values.
- The progress spinner reports `modifiedCount` vs. total and only increments when `stripCommentsFromFile` writes back; keep that count accurate to preserve trust in the `ora` message.
- `runStrip` skips non-existent files (deleted in git) early and tells users to fall back to `--all`; maintain that early exit so the command never tries to mutate missing paths.

### Utilities & Helpers
- `isBinaryFile` scans the first kilobyte for zero bytes and known signatures; treat `readFileSync`/`writeFileSync` errors as binary failures by returning `true` or `null` so callers can skip gracefully.
- `formatBytes` lives in `src/utils/formatting.ts` and returns the human-readable size used by `writeOutput`; reuse it whenever a byte-count summary is user-visible.
- `Logger` is a thin wrapper around `ora` that respects a `silent` flag; instantiate it with `new Logger(silent)` if you need to silence the spinner on CI.
- When using `execSync` for git metadata, set `encoding: 'utf-8'` and `stdio: 'ignore'` where we only care about the result, and always guard with try/catch blocks to avoid crashing non-git working directories.

## Repository Layout
- `src/index.ts` boots the CLI, wires Commander, and forwards arguments to `runBundle` or `runStrip`; follow its structure when adding new top-level commands or options.
- `src/commands/strip.ts` implements the cleanup workflow, handles git vs. full-scan modes, and branches into prompts and stripping helpers.
- `src/core` contains `scanner.ts`, `processor.ts`, `filter.ts`, and `stripper.ts`; keep core algorithms isolated so the CLI machinery only orchestrates high-level flows.
- `src/config` holds `defaults.ts` and `priority.ts`; route new configuration knobs there and expose them as named exports for `collectFilesRecursively` to consume.
- `src/cli` collects history and output helpers; reuse `addToHistory`, `showHistoryMenu`, and `writeOutput` whenever you need consistent persistence or logging.
- `src/utils` houses small stateless helpers like `git.ts`, `formatting.ts`, `fs.ts`, and `logger.ts`; prefer importing these instead of duplicating logic.
- Use `src/types.ts` as the single source of truth for shared interfaces; extend it when new shapes need to be shared across directories.
- Keep `dist/` out of source control; it is generated by `bun run build` and already excluded via `.gitignore`/`package.json` `files`.

## History Storage
- `HISTORY_FILE` lives at `~/.config/kodu/history.json` and is created lazily via `ensureHistoryFileExists` before every read or write.
- `loadHistory` and `saveHistory` wrap JSON parsing/serialization; they swallow errors and reset to an empty array if the file ever becomes corrupt.
- `addToHistory` deduplicates commands before unshifting, enforces `MAX_HISTORY_ITEMS`, and writes back with pretty JSON so humans can inspect the file.
- `showHistoryMenu` renders a `prompts` select menu; it appends a `Cancel` option and guards against out-of-range choices before returning the selected command tokens.
- When replaying history, `src/index.ts` chooses `program.parseAsync` for `strip` entries and `runBundle` followed by `--no-history` for others so loops do not re-record the replayed command.
## Documentation & README
- The repository README describes the CLI flags, `strip` command, priority rules, and default exclusions; keep it in sync with any user-impacting change.
- Mention new features, like the code cleanup tool or history menu, in the README so outside contributors understand how to exercise them.
- When you document new defaults or exclusions, update both `src/config/defaults.ts` and the README `## üö´ Default Exclusions` section to avoid confusion.
- Use the README‚Äôs `### ‚öôÔ∏è Options & Flags` tables as the ground truth for what options exist and how they map to CLI flags.

## Release & Publishing
- `bun run prepublishOnly` already runs `bun run build`, so rely on it whenever you‚Äôre preparing a release tarball.
- The published package only includes `dist`, `README.md`, and `LICENSE`; make sure generated assets stay under `dist` and nothing else sneaks into `package.json`‚Äôs `files` array.
- Do not commit `dist/index.js` (Git ignores it via `.gitignore`), but do verify that `bun run build` succeeds before tagging, because the bundled CLI is what npm consumers install.
- Keep the `version` field in `package.json` in sync with the git tag you plan to publish; we follow semantic versioning, so increment patch for fixes, minor for features, major for breaking changes.
- If you add release automation later, hook into `bun run build` and `bun run lint` so the release pipeline mirrors local safeguards.

## Troubleshooting
- `getGitChangedFiles` depends on a clean-enough `git status`; if it throws, the warning message is deliberately friendly and the command falls back to `--all` so as not to block work.
- `collectFilesRecursively` swallows `EACCES`/`EPERM` when descending directories; if you see missing files, ensure permissions or add them to `DEFAULT_CONFIG.EXCLUDED_DIRS`.
- The `strip` command warns when no changed files are found and suggests `--all`; keep that behavior so we never mutate deleted paths.
- When `runBundle` lists skipped files, the files are either too large, binary, or unreadable; inspect the `skippedFiles` array from `generateOutputContent` to diagnose.
- History operations that fail to write log an error but otherwise continue; if `~/.config/kodu` is writable then history should rebuild automatically.
- When CLI arguments look odd inside `program.parse`, check `showHistoryMenu` interfering with `process.argv`; this only happens when no args are provided and history is replayed.

## Toolchain Notes
- `tsconfig.json` runs with `strict: true`, `noFallthroughCasesInSwitch`, `noUncheckedIndexedAccess`, and `noImplicitOverride`, so new code must satisfy strict typing rules without relying on relaxed fallbacks.
- `biome.json` enforces `noUnusedImports`, `noUnusedVariables`, and disables `noNonNullAssertion` plus `useImportType`; keep `organizeImports` on so manual reordering is unnecessary.
- The dev dependency `npm-run-all` is used by the `check` script; when extending scripts that involve multiple steps, prefer `run-p` or `run-s` so the existing pattern stays intact.
- `bun.lock` and `dist/` are excluded from the npm package via `package.json`‚Äôs `files` array, so build artifacts never slip into published packages.

## Cursor / Copilot Rules
- There are currently no `.cursor/rules/` directories, no `.cursorrules`, and no `.github/copilot-instructions.md` files in this repo.
- If those files appear later, add a dedicated section to this guide and call out any overrides before changing the rest of the workflow.

## Suggested Next Steps for Agents
- Always run `bun run check` before a pull request to avoid lint or type regressions.
- When you touch CLI behavior, validate manual scenarios (`kodu`, `kodu strip`, `kodu strip -y`) and consider adding fixture directories that mimic README descriptions so future agents can test them automatically.
